# Module 2 : The Staging Area

## A) Initialize Tracking with Git

- Create a directory & switch to it :

```bash
mkdir git-and-github
cd git-and-github
```

- Check if git is already initiated in the directory, i.e., check if the directory is already a git repo :

```bash
git status
```

> **NOTE** : A **repository/repo** is a workspace/directory which has tracking of the changes made inside it, like adding new fies, deleting/modifying the content of the files etc., enabled, by the use of git. Typically, it has a `.git` directory in it.

- Now, initialize git tracking in it, or make it a git repo :

```bash
git init
git status # Gives a different result
```

> **NOTE** : This creates a `.git/` directory which tracks all the versions of our code & gives us the ability to control & store the different versions of the code.

- Add some code (a **Flask App** within a _virtual environment_ & a `.env` file).

## B) The 3 stages of tracking : **Working**, **Staging** & **Commit** Areas

> **Question** : What are **working**, **staging** & **commit** areas?

- **Working Area** : It consists of the changes that aren't yet permitted to be tracked or aren't tracked.
- **Staging Area (or Index)** : It consists of the changes made in a repo that are being tracked by git, but not yet committed to be saved as a checkpoint/commit.
- **Commit Area** : It consists of the changes that are stored as a checkpoint with a message at a timestamp, inorder to come back (or time travel) back to them in future.

> **Question** : What are _Untracked files_, _Changes to be committed_ & _Changes not staged for commit_?

- **Untracked Files** : The files which aren't staged atleast once after their creation, i.e., the files that still are in the working area.
- **Changes to be committed** : The changes in the files that are staged, but not yet committed, i.e., the files that still are in the staging area.
- **Changes not staged for commit** : The changes that are made in a file after it is staged

## C) Adding files to the **Staging Area**

> **NOTE** : Add 4 files - `test.txt`, `edit.txt`, `delete.txt`, `commit.txt`

- Add the updates to the staging area :

```bash
git status # Shows 4 untracked files

rm test.txt
git status # Shows 3 untracked files

git add edit.txt delete.txt commit.txt
git status # Shows 3 new files added to staging

rm delete.txt
git status # Shows 1 file deleted, yet 3 files in the to-be-committed changes
```

> **NOTE** : Hence, git counts in terms of changes, & not files

```bash
git add . # Adds all changes in the current directory to the staging area
git status # Shows 2 files in the to-be-committed changes
```

- Edit the `edit.txt`

```bash
git status # Shows 1 file modified, & 2 files in the to-be-committed changes
git add -A # Adds all changes in the repo in all nested directories to the staging area
git status # Shows 2 files in the to-be-committed changes
```

- Check the modifications in the repo :

```bash
git diff # Shows nthng, as it is used to show the differences bw committed files

# Yet, we can use it for staged files
git diff --staged edit.txt
```

## D) Undoing the staging of changes

- Undo staging of changes or remove the adds from the staging area :

```bash
git reset # Unstages all files
git status # Shows 2 untracked files
```

## E) Committing updates to the Commit Area

- Commit the changes related to the `commit.txt` file to the **Commit Area** :

```bash
git status # Shows 2 untracked files

git add -A
git status # Shows 2 files in the -to-be-committed changes

# Since we don't want to commit edit.txt yet, we unstage only that file
git reset edit.txt # Unstages the changes related only to that file

# Commit
git commit -m 'Added commit.txt'
git status # Shows 1 untracked file
git diff # Shows nthng, as no data changed in the committed files from the previous commit
```

> **Question** : What is a commit, a commit-hash & when will it change?

- **Commit** : A snapshot of our codebase at a given point of time, which stores the state of our commit at that time, like :
  - the changes made till then from the previous commit
  - the author who made the snapshot
  - the date & time of when it was made
  - an optional message which gives the overview of the changes established in that commit
  - the previous commit's hash.
- The series of commits in the timeline order is known as **Commit History**.
- **Commit Hash** : A unique SHA1 hash which is generated by all the components of a commit, which changes when we :

  - update the commit message
  - update the changes made that the commit is containing etc.

- Edit the `commit.txt`

```bash
git status
git diff # Shows nthng, as the change isn't staged yet
git status

git add commmit.txt
git status
git diff --staged commit.txt # Shows that a new line is added
git diff # Shows the same

git add -A
git status
git commit -m 'Added edit.txt & edited commit.txt'
git status
```

- Check the commit history of the repo :

```bash
git log # Shows you the commit hash, author, date & time of commit, & the commit message
```

## G) The Theory behind the structure of tracking

- The structure of a git tracking is a _Directed Acyclic Graph_ or **DAG**.
- If there's only 1 branch (which is **master/main** by default), then its a **Singly Linked List**, cz each commit has a link to its previous commit's hash.
- **HEAD** pointer is the latest commit in the current branch you are in. Hence, its the head of the Linked List if you're dealing with a single branch.
